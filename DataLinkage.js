/********** SJA-V1 | DataLinkage.js – UUID-based Cross-Sheet Linking **********/

/**
 * DATA LINKAGE SYSTEM
 * ====================
 * Links transactions across sheets using UUID:
 * - Sheet1: Main transactions (UUID as primary key)
 * - Accounts: Unified account registry with balances (merged from Account_Registry, Account_Balances, Balances)
 * - Classifier_Map: Category rules by merchant pattern
 * - Budgets: Budget tracking per category
 * 
 * UUID Format: TXN-XXXXXXXX-XXXX (generated by Core_Utils)
 */

// ============================================
// CACHING FOR SPEED
// ============================================
var CACHE_KEYS = {
  ACCOUNTS_INDEX: 'SJA_ACCOUNTS_IDX',
  BALANCES_INDEX: 'SJA_BALANCES_IDX',
  CATEGORY_MAP: 'SJA_CAT_MAP',
  DASHBOARD_DATA: 'SJA_DASH_DATA',
  TRANSACTIONS_RECENT: 'SJA_TXN_RECENT'
};

var CACHE_TTL = {
  SHORT: 60,      // 1 minute for frequently changing data
  MEDIUM: 300,    // 5 minutes for semi-static data
  LONG: 900       // 15 minutes for static data like accounts
};

/**
 * Get cached data or fetch fresh
 */
function getCachedOrFetch_(cacheKey, fetchFn, ttl) {
  var cache = CacheService.getScriptCache();
  var cached = cache.get(cacheKey);
  
  if (cached) {
    try {
      return JSON.parse(cached);
    } catch (e) {
      Logger.log('Cache parse error for ' + cacheKey + ': ' + e.message);
    }
  }
  
  var data = fetchFn();
  
  try {
    cache.put(cacheKey, JSON.stringify(data), ttl || CACHE_TTL.MEDIUM);
  } catch (e) {
    Logger.log('Cache put error for ' + cacheKey + ': ' + e.message);
  }
  
  return data;
}

/**
 * Invalidate specific cache
 */
function invalidateCache_(cacheKey) {
  CacheService.getScriptCache().remove(cacheKey);
}

/**
 * Invalidate all related caches
 */
function invalidateAllCaches_() {
  var cache = CacheService.getScriptCache();
  Object.keys(CACHE_KEYS).forEach(function(k) {
    cache.remove(CACHE_KEYS[k]);
  });
  Logger.log('✅ All caches invalidated');
}

// ============================================
// ACCOUNT LINKING
// ============================================

/**
 * Build account index from Accounts sheet and KNOWN_ACCOUNTS
 * Returns: { byNumber: { '9767': {...}, ... }, byName: { ... } }
 */
function buildAccountsIndex_() {
  var index = { byNumber: {}, byName: {}, byBank: {} };
  
  // 1. Load from KNOWN_ACCOUNTS (BankSMS_Patterns.js)
  if (typeof KNOWN_ACCOUNTS !== 'undefined') {
    for (var num in KNOWN_ACCOUNTS) {
      var acc = KNOWN_ACCOUNTS[num];
      index.byNumber[num] = {
        number: num,
        name: acc.owner || '',
        bank: acc.bank || '',
        type: acc.type || 'حساب',
        isMine: acc.isMine || false,
        source: 'KNOWN_ACCOUNTS'
      };
    }
  }
  
  // 2. Load from KNOWN_CARDS
  if (typeof KNOWN_CARDS !== 'undefined') {
    for (var cardNum in KNOWN_CARDS) {
      var card = KNOWN_CARDS[cardNum];
      index.byNumber[cardNum] = {
        number: cardNum,
        name: card.owner || '',
        bank: card.bank || '',
        type: card.type || 'بطاقة',
        isMine: card.isMine || false,
        source: 'KNOWN_CARDS'
      };
    }
  }
  
  // 3. Load from Accounts sheet (overrides if exists)
  try {
    var sh = _sheet('Accounts');
    var lastRow = sh.getLastRow();
    if (lastRow >= 2) {
      var rows = sh.getRange(2, 1, lastRow - 1, 7).getValues();
      rows.forEach(function(r) {
        var num = String(r[2] || '').trim();
        if (num) {
          index.byNumber[num] = {
            number: num,
            name: String(r[0] || ''),
            type: String(r[1] || 'حساب'),
            bank: String(r[3] || ''),
            aliases: String(r[4] || ''),
            isMine: String(r[5] || '').toLowerCase() === 'true',
            isInternal: String(r[6] || '').toLowerCase() === 'true',
            source: 'Accounts_Sheet'
          };
          
          // Index by name too
          var name = String(r[0] || '').toLowerCase();
          if (name) index.byName[name] = index.byNumber[num];
        }
      });
    }
  } catch (e) {
    Logger.log('Error loading Accounts sheet: ' + e.message);
  }
  
  return index;
}

/**
 * Get accounts index (cached)
 */
function getAccountsIndex_() {
  return getCachedOrFetch_(CACHE_KEYS.ACCOUNTS_INDEX, buildAccountsIndex_, CACHE_TTL.LONG);
}

/**
 * Find account by number (last 4 digits)
 */
function findAccountByNumber_(number) {
  if (!number) return null;
  var num = String(number).trim();
  var index = getAccountsIndex_();
  return index.byNumber[num] || null;
}

/**
 * Check if transfer is between user's own accounts
 */
function checkInternalTransfer_(fromAccount, toAccount) {
  var fromAcc = findAccountByNumber_(fromAccount);
  var toAcc = findAccountByNumber_(toAccount);
  
  if (!fromAcc || !toAcc) return { isInternal: false, reason: 'unknown_account' };
  if (!fromAcc.isMine || !toAcc.isMine) return { isInternal: false, reason: 'not_both_mine' };
  
  return { isInternal: true, from: fromAcc, to: toAcc };
}

// ============================================
// BALANCE TRACKING
// ============================================

/**
 * Update balance after transaction
 * Now uses unified Accounts sheet (column F = الرصيد)
 * @param {string} accountNumber - Last 4 digits of account
 * @param {number} amount - Transaction amount
 * @param {boolean} isIncoming - True if money coming in
 */
function updateAccountBalance_(accountNumber, amount, isIncoming) {
  if (!accountNumber || !amount) return;
  
  try {
    // Use unified Accounts sheet - balance is in column 5 (الرصيد)
    var sh = _sheet('Accounts');
    
    // Ensure headers exist
    if (sh.getLastRow() === 0) {
      sh.appendRow(['الاسم', 'النوع', 'الرقم', 'البنك', 'الرصيد', 'آخر_تحديث', 'حسابي', 'SMS_Pattern', 'أسماء_بديلة', 'ملاحظات']);
      sh.setFrozenRows(1);
    }
    
    var lastRow = sh.getLastRow();
    var found = false;
    
    if (lastRow >= 2) {
      // Column C (3) = الرقم, Column E (5) = الرصيد, Column F (6) = آخر_تحديث
      var data = sh.getRange(2, 3, lastRow - 1, 4).getValues(); // C, D, E, F
      for (var i = 0; i < data.length; i++) {
        if (String(data[i][0]).trim() === String(accountNumber).trim()) {
          var currentBalance = Number(data[i][2]) || 0; // Column E (الرصيد)
          var newBalance = isIncoming ? currentBalance + amount : currentBalance - amount;
          sh.getRange(i + 2, 5).setValue(newBalance);  // Column E
          sh.getRange(i + 2, 6).setValue(new Date());  // Column F
          found = true;
          break;
        }
      }
    }
    
    // If account not found, add it
    if (!found) {
      var initialBalance = isIncoming ? amount : -amount;
      sh.appendRow(['حساب ' + accountNumber, 'حساب', accountNumber, '', initialBalance, new Date(), 'TRUE', '', '', '']);
    }
    
    // Invalidate cache
    invalidateCache_(CACHE_KEYS.ACCOUNTS_INDEX);
    
  } catch (e) {
    Logger.log('Error updating balance: ' + e.message);
  }
}

/**
 * Get all balances from unified Accounts sheet (cached)
 */
function getAllBalances_() {
  return getCachedOrFetch_(CACHE_KEYS.BALANCES_INDEX, function() {
    var balances = {};
    try {
      // Use unified Accounts sheet
      var sh = _sheet('Accounts');
      var lastRow = sh.getLastRow();
      if (lastRow >= 2) {
        // Columns: الاسم(1), النوع(2), الرقم(3), البنك(4), الرصيد(5), آخر_تحديث(6)
        var data = sh.getRange(2, 1, lastRow - 1, 6).getValues();
        data.forEach(function(r) {
          var accNum = String(r[2] || '').trim(); // Column C (الرقم)
          if (accNum) {
            balances[accNum] = {
              name: r[0] || '',      // الاسم
              type: r[1] || '',      // النوع
              account: accNum,       // الرقم
              bank: r[3] || '',      // البنك
              balance: Number(r[4]) || 0,  // الرصيد
              lastUpdate: r[5] || null     // آخر_تحديث
            };
          }
        });
      }
    } catch (e) {
      Logger.log('Error getting balances: ' + e.message);
    }
    return balances;
  }, CACHE_TTL.SHORT);
}

// ============================================
// TRANSACTION LINKAGE
// ============================================

/**
 * Enrich transaction with account info
 * Called after AI parsing, before saving to Sheet1
 */
function enrichTransactionWithAccountInfo_(txn) {
  // Extract account/card from SMS
  var accNum = txn.accNum || extractAccountFromText_(txn.raw);
  var cardNum = txn.cardNum || extractCardFromText_(txn.raw);
  
  // Find account info
  var accInfo = findAccountByNumber_(accNum) || findAccountByNumber_(cardNum);
  
  if (accInfo) {
    txn.accNum = accNum || cardNum;
    txn.accountName = accInfo.name;
    txn.bank = accInfo.bank;
    txn.isMine = accInfo.isMine;
    
    // Check for internal transfer
    var toAccount = extractToAccountFromText_(txn.raw);
    if (toAccount) {
      var transferCheck = checkInternalTransfer_(accNum || cardNum, toAccount);
      if (transferCheck.isInternal) {
        txn.isInternal = true;
        txn.category = 'تحويل داخلي';
      }
    }
  }
  
  return txn;
}

/**
 * Extract account number from SMS text
 */
function extractAccountFromText_(text) {
  if (!text) return null;
  
  // Patterns: من:9767, الى:8001, XXX9767, XXXX8001, حساب:1929*
  var patterns = [
    /من[::]?\s*(\d{4})/i,
    /الى[::]?\s*(\d{4})/i,
    /X{3,4}(\d{4})/i,
    /حساب[::]?\s*(\d{4})/i,
    /Account.*?(\d{4})/i
  ];
  
  for (var i = 0; i < patterns.length; i++) {
    var match = text.match(patterns[i]);
    if (match) return match[1];
  }
  
  return null;
}

/**
 * Extract card number from SMS text
 */
function extractCardFromText_(text) {
  if (!text) return null;
  
  // Patterns: بطاقة:4912, X3474, **0305, ***4495
  var patterns = [
    /بطاقة[::]?\s*(\d{4})/i,
    /[Xx](\d{4})/,
    /\*{2,3}(\d{4})/,
    /Card.*?(\d{4})/i
  ];
  
  for (var i = 0; i < patterns.length; i++) {
    var match = text.match(patterns[i]);
    if (match) return match[1];
  }
  
  return null;
}

/**
 * Extract destination account for transfers
 */
function extractToAccountFromText_(text) {
  if (!text) return null;
  
  var patterns = [
    /الى[::]?\s*[^0-9]*(\d{4})/i,
    /لـ\s*(\d{4})/i,
    /To.*?(\d{4})/i
  ];
  
  for (var i = 0; i < patterns.length; i++) {
    var match = text.match(patterns[i]);
    if (match) return match[1];
  }
  
  return null;
}

// ============================================
// FAST DASHBOARD DATA (OPTIMIZED)
// ============================================

/**
 * Get dashboard data with aggressive caching
 * Reduces backend calls significantly
 */
function getFastDashboardData_(forceRefresh) {
  if (forceRefresh) {
    invalidateCache_(CACHE_KEYS.DASHBOARD_DATA);
  }
  
  return getCachedOrFetch_(CACHE_KEYS.DASHBOARD_DATA, function() {
    var startTime = Date.now();
    
    var data = {
      kpi: calculateKPI_(),
      recentTransactions: getRecentTransactionsOptimized_(30),
      budgets: getBudgetsOptimized_(),
      accounts: getAccountsIndex_(),
      loadTime: 0
    };
    
    data.loadTime = Date.now() - startTime;
    Logger.log('Dashboard data loaded in ' + data.loadTime + 'ms');
    
    return data;
  }, CACHE_TTL.SHORT);
}

/**
 * Calculate KPI efficiently
 */
function calculateKPI_() {
  var now = new Date();
  var startMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  var endMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
  
  var s1 = _sheet('Sheet1');
  var lastRow = s1.getLastRow();
  
  if (lastRow < 2) {
    return { incomeM: 0, spendM: 0, netM: 0 };
  }
  
  // Read only necessary columns: Date(2), Amount(9), Type(12), Raw(13)
  var data = s1.getRange(2, 2, lastRow - 1, 12).getValues();
  
  var income = 0, spend = 0;
  
  data.forEach(function(r) {
    var date = r[0]; // Column B (Date)
    if (!(date instanceof Date) || date < startMonth || date >= endMonth) return;
    
    var amount = Math.abs(Number(r[7]) || 0); // Column I (Amount)
    var type = String(r[10] || '');  // Column L (Type)
    var raw = String(r[11] || '');   // Column M (Raw)
    var category = String(r[9] || ''); // Column K (Category)
    
    // Skip OTP/verification messages
    if (category === 'تحقق' || /رمز مؤقت|رمز التحقق|OTP/i.test(raw)) return;
    
    // Skip declined transactions
    if (category === 'مرفوضة' || /رصيد غير كافي|Declined/i.test(raw)) return;
    
    var isIncoming = /(وارد|إيداع|استلام|راتب|دعم|Incoming)/i.test(type + ' ' + raw);
    
    if (isIncoming) {
      income += amount;
    } else {
      spend += amount;
    }
  });
  
  return {
    incomeM: income,
    spendM: spend,
    netM: income - spend
  };
}

/**
 * Get recent transactions optimized
 */
function getRecentTransactionsOptimized_(limit) {
  limit = limit || 30;
  
  var s1 = _sheet('Sheet1');
  var lastRow = s1.getLastRow();
  
  if (lastRow < 2) return [];
  
  var startRow = Math.max(2, lastRow - limit + 1);
  var data = s1.getRange(startRow, 1, lastRow - startRow + 1, 13).getValues();
  
  var transactions = [];
  var tz = Session.getScriptTimeZone();
  
  for (var i = data.length - 1; i >= 0; i--) {
    var r = data[i];
    transactions.push({
      uuid: r[0] || '',
      date: (r[1] instanceof Date) ? Utilities.formatDate(r[1], tz, 'yyyy-MM-dd HH:mm') : '',
      accNum: r[6] || '',
      cardNum: r[7] || '',
      amount: Number(r[8]) || 0,
      merchant: r[9] || '',
      category: r[10] || '',
      type: r[11] || ''
    });
  }
  
  return transactions;
}

/**
 * Get budgets optimized
 */
function getBudgetsOptimized_() {
  try {
    var sh = _sheet('Budgets');
    var lastRow = sh.getLastRow();
    if (lastRow < 2) return [];
    
    var data = sh.getRange(2, 1, lastRow - 1, 4).getValues();
    return data.map(function(r) {
      return {
        category: r[0] || '',
        budget: Number(r[1]) || 0,
        spent: Number(r[2]) || 0,
        remaining: Number(r[3]) || 0
      };
    });
  } catch (e) {
    return [];
  }
}

// ============================================
// UI API WRAPPER (FAST)
// ============================================

/**
 * Fast API for frontend - returns all needed data in one call
 * Use this instead of multiple separate calls
 */
function SOV1_FAST_getDashboard() {
  try {
    return {
      success: true,
      data: getFastDashboardData_(false),
      timestamp: new Date().toISOString()
    };
  } catch (e) {
    return {
      success: false,
      error: e.message,
      data: null
    };
  }
}

/**
 * Force refresh dashboard data
 */
function SOV1_FAST_refreshDashboard() {
  try {
    invalidateAllCaches_();
    return {
      success: true,
      data: getFastDashboardData_(true),
      timestamp: new Date().toISOString()
    };
  } catch (e) {
    return {
      success: false,
      error: e.message
    };
  }
}
